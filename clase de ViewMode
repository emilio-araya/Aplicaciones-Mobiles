Actividad 2.3 
clase de ViewModel  en android 

La clase ViewModel es una l贸gica empresarial o un contenedor de estado a nivel de pantalla. Expone el estado a la IU y encapsula la l贸gica empresarial relacionada.
Su principal ventaja es que almacena en cach茅 el estado y lo conserva durante los cambios de configuraci贸n.
Esto significa que la IU no tiene que recuperar datos cuando navegas entre actividades o si sigues cambios de configuraci贸n, como cuando rotas la pantalla


Beneficios de ViewModel

La alternativa a un ViewModel es una clase simple que contiene los datos que muestras en tu IU. Esto puede convertirse en un problema cuando navegas entre actividades o destinos de Navigation. 
Si lo haces, esos datos se destruir谩n si no los almacenas con el mecanismo de guardado de estado de instancias. ViewModel proporciona una API conveniente para la persistencia de datos que resuelve este problema.

Los beneficios clave de la clase ViewModel son b谩sicamente dos:

Te permite conservar el estado de la IU.
Proporciona acceso a la l贸gica empresarial

1. Definici贸n del ContadorViewModel (Kotlin)
El ViewModel contiene el dato (_contador) y la l贸gica para modificarlo (incrementarContador). Usamos LiveData para que el dato sea observable por la IU.

Kotlin

import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.ViewModel

// 1. La clase debe heredar de ViewModel
class ContadorViewModel : ViewModel() {

    // 2. MutableLiveData es donde se guarda el dato de forma interna.
    // Usamos 'private' para que solo el ViewModel pueda cambiar su valor.
    private val _contador = MutableLiveData<Int>()

    // 3. LiveData es la versi贸n p煤blica (inmutable) del dato.
    // La Activity/Fragment solo puede 'observar' este dato, no cambiarlo.
    val contador: LiveData<Int> = _contador

    // 4. Inicializamos el contador al crear el ViewModel
    init {
        _contador.value = 0
    }

    // 5. L贸gica de Negocio: M茅todo para modificar el estado
    fun incrementarContador() {
        _contador.value = (_contador.value ?: 0) + 1
    }
}


2. Uso en una Activity (Kotlin)
La Activity solicita la instancia del ViewModel y luego observa el LiveData para actualizar la IU.

Kotlin

import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle
import android.widget.Button
import android.widget.TextView
import androidx.lifecycle.ViewModelProvider // Necesario para obtener el ViewModel

class MainActivity : AppCompatActivity() {

    // 1. Declaraci贸n del ViewModel
    private lateinit var viewModel: ContadorViewModel
    private lateinit var contadorTextView: TextView
    private lateinit var botonIncrementar: Button

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        contadorTextView = findViewById(R.id.text_contador)
        botonIncrementar = findViewById(R.id.boton_incrementar)

        // 2. OBTENER LA INSTANCIA del ViewModel.
        // El sistema se encarga de crearla o devolver la ya existente (la que sobrevive a rotaciones).
        viewModel = ViewModelProvider(this).get(ContadorViewModel::class.java)

        // 3. OBSERVACIN del LiveData
        // Cada vez que 'viewModel.contador' cambie, este bloque se ejecuta
        // y actualiza el TextView.
        viewModel.contador.observe(this) { nuevoValor ->
            contadorTextView.text = "Contador: $nuevoValor"
        }

        // 4. Conexi贸n del evento de la IU a la L贸gica del ViewModel
        botonIncrementar.setOnClickListener {
            viewModel.incrementarContador() // Llama al m茅todo del ViewModel
        }
    }
}
Resumen del Flujo 
Inicio: Cuando la MainActivity se crea, solicita un ContadorViewModel.

Dato: El ViewModel inicializa su _contador interno a 0.

Observaci贸n: La Activity se suscribe a los cambios del viewModel.contador. Muestra "Contador: 0".

Interacci贸n: El usuario toca el bot贸n.

L贸gica: La Activity llama a viewModel.incrementarContador(). El ViewModel incrementa su valor interno a 1.

Actualizaci贸n: Como el valor de _contador (que es LiveData) ha cambiado, notifica a la Activity (al bloque observe). La Activity actualiza el TextView a "Contador: 1".

 La Ventaja Clave en Acci贸n
Si rotas la pantalla (o cierras y vuelves a abrir la Activity con el bot贸n de atr谩s):

La MainActivity es destruida y recreada.

Sin embargo, cuando ViewModelProvider(this).get(...) es llamado de nuevo, devuelve la misma instancia de ContadorViewModel que ya exist铆a.

Dado que el _contador en el ViewModel sigue siendo 1, la nueva Activity lo observa inmediatamente y muestra "Contador: 1" sin perder el estado.

